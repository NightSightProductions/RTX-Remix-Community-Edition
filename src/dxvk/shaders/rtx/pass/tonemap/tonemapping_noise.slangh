/*
* Copyright (c) 2024, NVIDIA CORPORATION. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
#pragma once

#include "rtx/pass/tonemap/tonemapping.h"
#include "rtx/utility/noise.slangh"

// Applies dithering to a color, ideally one in gamma space (for proper perceptual dithering).
// This does monochromatic dithering instead of using a different dithering pattern per
// channel - this correlates errors, but the monochromatic noise might be preferable from
// a visual, filmic standpoint as chromatic noise is more visually distracting typically and undesirable.
// The dithering pattern may also be optionally shifted over time, this may make the result
// visually smoother (due to persistence of vision averaging temporal noise samples together),
// but also may be more visually distracting in some cases versus a static pattern.
// Finally, this dithering only should be used on 8 bit unorm output targets (assuming quantization
// is done on write to a texture).
float3 ditherTo8Bit(
  const float3 value,
  const uint2 pixelPosition,
  const uint frameIndex,
  const bool enableDithering,
  const bool enableTemporalDithering,
)
{
  // Early out if dithering is not enabled

  if (!enableDithering)
  {
    return value;
  }

  // Create a RNG for dithering
  // Note: RNG object used as it is backed by a blue noise texture which should allow for more
  // uniform-looking noise for dithering compared to pure random based noise.

  // Note: Use a constant temporal index of 0 if temporal dithering is disabled to have the same
  // pattern on every frame.
  const uint temporalIndex = enableTemporalDithering ? frameIndex : 0;
  RNG rng = createRNG(pixelPosition, temporalIndex);

  // Dither the color value

  // Note: Convert from [0, 1) to [-0.5 / 255, 0.5 / 255)
  const float adjustment = (getNextSampleBlueNoise(rng) - 0.5f) / 255.0f;

  return value + float3(adjustment);
}

// Todo: 10 bit dither in the future for HDR output.

// Applies high-quality dithering for HDR output using blue noise
// This handles PQ/HLG transfer functions and 10/12-bit precision
// Uses the same blue noise infrastructure as SDR for consistent quality
float3 ditherToHDR(
  const float3 value,
  const uint2 pixelPosition,
  const uint frameIndex,
  const bool enableDithering,
  const bool enableTemporalDithering,
  const uint hdrFormat, // 0=Linear, 1=PQ, 2=HLG
  const float ditherAmplitude // Multiplier on format-appropriate base amplitude
)
{
  // Early out if dithering is not enabled
  if (!enableDithering)
  {
    return value;
  }

  // Create a RNG for dithering using the same blue noise as SDR
  const uint temporalIndex = enableTemporalDithering ? frameIndex : 0;
  RNG rng = createRNG(pixelPosition, temporalIndex);

  // Get high-quality blue noise sample
  const float blueNoise = getNextSampleBlueNoise(rng) - 0.5f; // [-0.5, 0.5)

  // Calculate format-appropriate base amplitude (similar to SDR's 1/255 approach)
  float baseAmplitude;
  
  if (hdrFormat == 1) {
    // PQ (HDR10): 10-bit quantization in PQ space
    baseAmplitude = 1.0f / 1024.0f; // ≈ 0.00098
  } else if (hdrFormat == 2) {
    // HLG: 10-bit quantization in HLG space  
    baseAmplitude = 1.0f / 1024.0f; // ≈ 0.00098
  } else {
    // Linear HDR: Use SDR-like amplitude since linear values can vary widely
    baseAmplitude = 1.0f / 512.0f; // ≈ 0.00195, slightly stronger for linear
  }

  // Apply user-configurable multiplier to the base amplitude
  const float finalAmplitude = baseAmplitude * ditherAmplitude;
  
  return value + float3(blueNoise * finalAmplitude);
}
